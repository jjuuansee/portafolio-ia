mutate(
h_j = round(f_j / sum(f_j), 3),
F_j = cumsum(f_j),
H_j = round(cumsum(h_j), 3)
)
tabla_frec2 <- tabla_frec %>%
select(intervalo, c_j, f_j, F_j, h_j, H_j)
knitr::kable(tabla_frec2, digits = 3)
# Histograma
ggplot(datos_pib, aes(x = pib_pc)) +
geom_histogram(binwidth = 10, boundary = 0) +
scale_x_continuous(
breaks = seq(0, max(datos_pib$pib_pc, na.rm = TRUE) + 10, by = 10),
minor_breaks = NULL
) +
labs(title = "Histograma del PIB per cápita",
x = "PIB per cápita (miles de US$)",
y = "Frecuencia") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))
# Distribución acumulada (lineal por tramos)
tabla_frec_lineal <- tabla_frec %>%
mutate(
H_j = zoo::na.locf(H_j, na.rm = FALSE),
H_j = ifelse(is.na(H_j), 0, H_j),
y_start = lag(H_j, default = 0),
x_start = a_inf,
x_end = a_sup,
y_end = H_j
)
tabla_frec_lineal_ext <- tabla_frec_lineal %>%
bind_rows(
tibble(x_start = -5, x_end = min(tabla_frec$a_inf),
y_start = 0, y_end = 0),
tibble(x_start = max(tabla_frec$a_sup),
x_end = max(tabla_frec$a_sup) + 10,
y_start = 1, y_end = 1)
)
ggplot(tabla_frec_lineal_ext) +
geom_segment(aes(x = x_start, xend = x_end, y = y_start, yend = y_end),
linewidth = 1) +
scale_x_continuous(
breaks = seq(0, max(tabla_frec$a_sup, na.rm = TRUE) + 10, by = 10),
minor_breaks = NULL
) +
labs(title = "Distribución acumulada del PIB per cápita",
x = "PIB per cápita (miles de US$)",
y = "Frecuencia acumulada") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))
breaks_desiguales <- c(seq(0, 30, by = 5), seq(40, 80, by = 10), seq(120, 270, by = 25))
tabla_frec <- datos_pib %>%
mutate(intervalo = cut(pib_pc, breaks = breaks_desiguales, right = FALSE)) %>%
count(intervalo, name = "f_j") %>%
complete(intervalo, fill = list(f_j = 0)) %>%
mutate(
a_inf = readr::parse_number(gsub(",.*", "", intervalo)),
a_sup = readr::parse_number(gsub(".*,", "", intervalo)),
c_j = (a_inf + a_sup) / 2
) %>%
arrange(a_inf) %>%
mutate(
h_j = round(f_j / sum(f_j), 3),
F_j = cumsum(f_j),
H_j = round(cumsum(h_j), 3)
)
tabla_frec2 <- tabla_frec %>%
select(intervalo, c_j, f_j, h_j, F_j, H_j)
knitr::kable(tabla_frec2, digits = 3)
tabla_frec3 <- tabla_frec %>%
mutate(ancho = a_sup - a_inf,
densidad = f_j / ancho)
ggplot(tabla_frec3) +
geom_rect(aes(xmin = a_inf, xmax = a_sup, ymin = 0, ymax = densidad)) +
scale_x_continuous(
breaks = tabla_frec3$c_j,
minor_breaks = NULL
) +
labs(title = "Histograma con densidades ajustadas",
x = "PIB per cápita (miles de US$)",
y = "Altura proporcional a la densidad") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))
# Indicadores a descargar: esperanza de vida y PIB per cápita
indicadores <- c(
esperanza_vida = "SP.DYN.LE00.IN",  # Life expectancy at birth
pib_pc = "NY.GDP.PCAP.CD"           # GDP per capita (current US$)
)
# Descargar datos más recientes para todos los países (con fallback)
datos_graficos <- WDI(
indicator = indicadores,
country   = "all",
latest    = 1,
extra     = TRUE
)
# Limpiar base: excluir agregados y mantener variables relevantes
datos_graficos <- datos_graficos %>%
filter(region != "Aggregates") %>%
select(
pais = country,
codigo_pais = iso2c,
region,
ingreso = income,
esperanza_vida,
pib_pc
) %>%
mutate(pib_pc = pib_pc / 1000)
# Limpiar ingreso y establecer orden explícito de niveles
datos_graficos_limpio <- datos_graficos %>%
filter(!is.na(ingreso) & ingreso != "Not classified") %>%
mutate(ingreso = factor(ingreso,
levels = c("Low income", "Lower middle income", "Upper middle income", "High income"),
ordered = TRUE
))
# 1. Gráfico de torta (solo demostrativo; preferimos barras apiladas)
datos_graficos_limpio %>% count(ingreso) %>%
ggplot(aes(x = "", y = n, fill = ingreso)) +
geom_col(width = 1) +
coord_polar("y") +
labs(title = "Distribución de países por nivel de ingreso",
fill = "Nivel de ingreso") +
theme_void()
# 2. Gráfico de barras
datos_graficos_limpio %>% count(ingreso) %>%
ggplot(aes(x = ingreso, y = n, fill = ingreso)) +
geom_col() +
labs(title = "Cantidad de países por nivel de ingreso",
x = "Nivel de ingreso", y = "Número de países") +
theme_minimal() +
theme(legend.position = "none")
# 3. Barras apiladas: región × ingreso
datos_graficos_limpio %>%
count(region, ingreso) %>%
ggplot(aes(x = region, y = n, fill = ingreso)) +
geom_col(position = "stack") +
labs(title = "Distribución de países por región y nivel de ingreso",
x = "Región", y = "Número de países", fill = "Ingreso") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
# 4. Densidad suavizada
ggplot(datos_graficos_limpio, aes(x = pib_pc)) +
geom_density(alpha = 0.5) +
labs(title = "Distribución estimada del PIB per cápita",
x = "PIB per cápita (miles de US$)", y = "Densidad") +
theme_minimal()
# 5. Boxplot: PIB per cápita
ggplot(datos_graficos_limpio, aes(x = pib_pc)) +
geom_boxplot() +
labs(title = "Diagrama de caja: PIB per cápita",
x = "PIB per cápita (miles de US$)") +
theme_minimal()
# 6. Boxplot: Esperanza de vida por ingreso
ggplot(datos_graficos_limpio, aes(x = ingreso, y = esperanza_vida, fill = ingreso)) +
geom_boxplot() +
labs(title = "Esperanza de vida por nivel de ingreso",
x = "Nivel de ingreso", y = "Esperanza de vida (años)") +
theme_minimal() +
theme(legend.position = "none")
# 7. Dispersión
ggplot(datos_graficos_limpio, aes(x = pib_pc, y = esperanza_vida)) +
geom_point(alpha = 0.6) +
labs(title = "PIB per cápita y esperanza de vida",
x = "PIB per cápita (miles de US$)",
y = "Esperanza de vida (años)") +
theme_minimal()
# 8. Dispersión con log en PIB per cápita
ggplot(datos_graficos_limpio, aes(x = log(pib_pc), y = esperanza_vida)) +
geom_point(alpha = 0.6) +
labs(title = "PIB per cápita (log) y esperanza de vida",
x = "Log de PIB per cápita (miles de US$)",
y = "Esperanza de vida (años)") +
theme_minimal()
# (E1) Resumen rápido de estructura y NA
datos_graficos_limpio %>% skim()
# (E2) Tablas por grupo (medidas robustas vs clásicas)
datos_graficos_limpio %>%
group_by(ingreso) %>%
summarise(
n = n(),
media_ev = mean(esperanza_vida, na.rm = TRUE),
mediana_ev = median(esperanza_vida, na.rm = TRUE),
sd_ev = sd(esperanza_vida, na.rm = TRUE),
iqr_ev = IQR(esperanza_vida, na.rm = TRUE)
)
# (E3) Correlación simple
with(datos_graficos_limpio, cor(log(pib_pc), esperanza_vida, use = "complete.obs"))
# (E4) Facetas por región
ggplot(datos_graficos_limpio, aes(x = log(pib_pc), y = esperanza_vida)) +
geom_point(alpha = 0.6) +
facet_wrap(~ region) +
labs(title = "Esperanza de vida vs log(PIB pc), por región")
# (E5) Exportar una tabla a CSV y un gráfico a PNG
write_csv(tabla_frec2, here("output", "tabla_frecuencias_pibpc.csv"))
ggsave(filename = here("output", "disp_logpib_ev.png"), width = 7, height = 5, dpi = 300)
# (E6) Codificación de países (ISO3) y join con otra fuente (demo)
datos_graficos_limpio <- datos_graficos_limpio %>%
mutate(iso3c = countrycode(codigo_pais, origin = "iso2c", destination = "iso3c"))
# (E7) Guardar RDS (formato R) para reusar sin volver a limpiar
saveRDS(datos_graficos_limpio, here("data", "datos_graficos_limpio.rds"))
# (E8) Información de sesión (para reproducibilidad en informes)
sessionInfo()
# Ejecución de código (Ctrl+Enter)
2+2
# Asignación de objetos y vectores
y <- 2+2
x <- c(1, 2, NA, 4)
typeof(x); length(x); is.na(x); sum(is.na(x))
# Tema visual global
theme_set(theme_minimal(base_size = 12))
typeof(x); length(x); is.na(x); sum(is.na(x))
# Factores (categóricas ordenadas)
f <- factor(c("bajo","medio","alto"), levels = c("bajo","medio","alto"), ordered = TRUE)
f
# Data frames vs tibbles (de tidyverse)
df <- data.frame(a = 1:3, b = c("u","v","w"))
tb <- tibble(a = 1:3, b = c("u","v","w"))
df; tb
glimpse(tb)
# Pipe: |> (base R) y %>% (magrittr/tidyverse)
tb |>
mutate(a2 = a^2) |>
summarise(media = mean(a2))
tb %>%
mutate(a2 = a^2) %>%
summarise(media = mean(a2))
# Verbos esenciales de dplyr
tb %>%
filter(a >= 2) %>%
select(b, a) %>%
arrange(desc(a)) %>%
mutate(flag = a > 2) %>%
group_by(flag) %>%
summarise(n = n())
# Comentar estas líneas una vez que las carpetas hayan sido creadas
dir.create(here("data"), showWarnings = FALSE, recursive = TRUE)
dir.create(here("output"), showWarnings = FALSE, recursive = TRUE)
# --- Datos: Lead time to import (LP.IMP.DURS.MD) ---
# Opción 1: descargar desde servidores de WDI
## Opción A: desde WDI
datos_wdi <- WDI(
country  = "all",
indicator = "LP.IMP.DURS.MD",
latest   = 1,
extra    = TRUE
)
# Renombrar y ordenar variables, filtrar observaciones NA y agregados de países
datos_wdi <- datos_wdi %>%
rename(pais = iso2c,
tiempo_impor = LP.IMP.DURS.MD,
nombre_pais = country
) %>%
filter(!is.na(tiempo_impor), region != "Aggregates", !pais %in% c("TD", "GA", "GN", "MR", "MD")) %>%
select(nombre_pais, pais, tiempo_impor)
# Tabla de frecuencias
tabla_frec <- datos_wdi %>%
count(tiempo_impor, name = "f_j") %>%
complete(tiempo_impor = full_seq(tiempo_impor, 1), fill = list(f_j = 0)) %>%
mutate(
F_j = cumsum(f_j),
h_j = f_j / sum(f_j),
H_j = cumsum(h_j)
)
# Formas alternativas de visualización de la tabla
print(tabla_frec)
# View(tabla_frec)  # descomentar en RStudio
as.data.frame(tabla_frec)
knitr::kable(tabla_frec, digits = 2)
# Gráfico de la función de cuantía (PMF)
ggplot(tabla_frec, aes(x = factor(tiempo_impor), y = h_j)) +
geom_segment(aes(xend = factor(tiempo_impor), yend = 0), linewidth = 1) +
labs(title = "Función de cuantía", x = "Días", y = "h_j") +
theme_minimal()
# Función de cuantía acumulada (CDF discreta)
tabla_frec_horiz <- tabla_frec %>%
mutate(tiempo_previo = dplyr::lag(tiempo_impor, default = min(tiempo_impor) - 1),
H_previo = dplyr::lag(H_j, default = 0))
print(tabla_frec_horiz)
ggplot() +
geom_segment(data = tabla_frec_horiz,
aes(x = tiempo_previo, xend = tiempo_impor,
y = H_previo, yend = H_previo),
arrow = arrow(type = "open", length = unit(0.2, "cm")),
linewidth = 1) +
geom_point(data = tabla_frec_horiz,
aes(x = tiempo_previo, y = H_previo),
size = 2) +
geom_segment(data = tabla_frec_horiz,
aes(x = tiempo_impor, xend = tiempo_impor,
y = H_previo, yend = H_j),
linetype = "dashed", linewidth = 1) +
scale_x_continuous(breaks = 0:15, minor_breaks = NULL) +
labs(title = "Función de cuantía acumulada",
x = "Días", y = "H_j") +
geom_segment(aes(x = max(tabla_frec$tiempo_impor),
xend = max(tabla_frec$tiempo_impor) + 1,
y = 1, yend = 1),
arrow = arrow(type = "open", length = unit(0.2, "cm")),
linewidth = 1) +
theme_minimal()
datos_wdi <- WDI(
country  = "all",
indicator = "LP.IMP.DURS.MD",
latest   = 1,
extra    = TRUE
)
# ============================================================
# Estadística Inferencial (UCU)
# Tema 1 - Introducción
# Práctico de R: introducción, EDA y gráficos con WDI
# ============================================================
# ------------------------------
# 0) Reproducibilidad y opciones
# ------------------------------
set.seed(1234)
options(scipen = 999)     # evitar notación científica en impresiones
options(dplyr.summarise.inform = FALSE)
# Conviene usar un R Project (.Rproj) para rutas relativas estables.
# 1 - Creá en tu disco una carpeta para este /practico1 y guardá allí este script
# 2 - Abrí un nuevo R Project y asignale la carpeta /practico1
# 3 - Volvé a cargar este script cuando se abra el proyecto
# 4 - Luego, el proyecto y el scirpt se guardan en forma independiente
# ------------------------------
# 1) Paquetes
# ------------------------------
# Instalación (solo 1ª vez; comentá cada línea cuando ya esté instalado)
# Podés instalarlos desde la barra amarilla que identifica paquetes faltantes.
install.packages("WDI")        # API del Banco Mundial
install.packages("dplyr")      # verbos de manipulación
install.packages("tidyr")      # reshape y tidying
install.packages("ggplot2")    # gráficos
install.packages("tibble")     # data frames "modernos"
install.packages("stringr")    # strings
install.packages("readr")      # lectura/escritura rápida CSV
install.packages("knitr")      # tablas/outputs bonitos
install.packages("janitor")    # clean_names(), tabyl(), etc.
install.packages("skimr")      # skim() resumen exploratorio
install.packages("lubridate")  # fechas
install.packages("forcats")    # factores
install.packages("scales")     # escalas en ggplot
install.packages("readxl")     # leer .xlsx
install.packages("countrycode")# códigos de país
install.packages("here")       # rutas relativas
install.packages("zoo")        # utilidades varias (na.locf, etc.)
install.packages("moments")    # asimetría y curtosis
# Carga de librerías (correr una vez por sesión de RStudio)
library(dplyr)
library(tidyverse)
library(tidyr)
library(ggplot2)
library(knitr)
library(stringr)
library(moments)
library(tibble)
library(WDI)
library(janitor)
library(skimr)
library(lubridate)
library(forcats)
library(scales)
library(readr)
library(readxl)
library(countrycode)
library(here)
# Tema visual global
theme_set(theme_minimal(base_size = 12))
# --------------------------------------------
# 2) Introducción
# --------------------------------------------
# Ejecución de código (Ctrl+Enter)
2+2
# Asignación de objetos y vectores
y <- 2+2
x <- c(1, 2, NA, 4)
typeof(x); length(x); is.na(x); sum(is.na(x))
# Factores (categóricas ordenadas)
f <- factor(c("bajo","medio","alto"), levels = c("bajo","medio","alto"), ordered = TRUE)
f
# Data frames vs tibbles (de tidyverse)
df <- data.frame(a = 1:3, b = c("u","v","w"))
tb <- tibble(a = 1:3, b = c("u","v","w"))
df; tb
glimpse(tb)
# Pipe: |> (base R) y %>% (magrittr/tidyverse)
tb |>
mutate(a2 = a^2) |>
summarise(media = mean(a2))
tb %>%
mutate(a2 = a^2) %>%
summarise(media = mean(a2))
# Verbos esenciales de dplyr
tb %>%
filter(a >= 2) %>%
select(b, a) %>%
arrange(desc(a)) %>%
mutate(flag = a > 2) %>%
group_by(flag) %>%
summarise(n = n())
# -----------------------------------
# 3) Utilidades de E/S
# -----------------------------------
# Estructura de carpetas:
#   /data       -> datos crudos .csv / .xlsx provistos en webasignatura
#   /output     -> tablas y gráficos exportados
#   este script -> en la raíz del proyecto (usá here::here() para rutas)
# Comentar estas líneas una vez que las carpetas hayan sido creadas
dir.create(here("data"), showWarnings = FALSE, recursive = TRUE)
dir.create(here("output"), showWarnings = FALSE, recursive = TRUE)
# ----------------------------------------
# 4) Lecturas básicas desde archivos locales
# ----------------------------------------
# Ejemplos (dejar comentado hasta tener los archivos):
# demo_csv  <- read_csv(here("data", "demo.csv"))
# demo_xlsx <- read_excel(here("data", "demo.xlsx"), sheet = 1)
# demo_csv %>% clean_names() %>% skim()
########################## REPASO ESTADÍSTICA DESCRIPTIVA Y EDA
# --- Datos: Lead time to import (LP.IMP.DURS.MD) ---
# Opción 1: descargar desde servidores de WDI
## Opción A: desde WDI
datos_wdi <- WDI(
country  = "all",
indicator = "LP.IMP.DURS.MD",
latest   = 1,
extra    = TRUE
)
# Opción 2: abrir archivo desde disco
# datos_wdi <- read_csv(here("data", "datos_wdi_1.csv"), show_col_types = FALSE)
# Renombrar y ordenar variables, filtrar observaciones NA y agregados de países
datos_wdi <- datos_wdi %>%
rename(pais = iso2c,
tiempo_impor = LP.IMP.DURS.MD,
nombre_pais = country
) %>%
filter(!is.na(tiempo_impor), region != "Aggregates", !pais %in% c("TD", "GA", "GN", "MR", "MD")) %>%
select(nombre_pais, pais, tiempo_impor)
# Tabla de frecuencias
tabla_frec <- datos_wdi %>%
count(tiempo_impor, name = "f_j") %>%
complete(tiempo_impor = full_seq(tiempo_impor, 1), fill = list(f_j = 0)) %>%
mutate(
F_j = cumsum(f_j),
h_j = f_j / sum(f_j),
H_j = cumsum(h_j)
)
# Formas alternativas de visualización de la tabla
print(tabla_frec)
# View(tabla_frec)  # descomentar en RStudio
as.data.frame(tabla_frec)
knitr::kable(tabla_frec, digits = 2)
# Gráfico de la función de cuantía (PMF)
ggplot(tabla_frec, aes(x = factor(tiempo_impor), y = h_j)) +
geom_segment(aes(xend = factor(tiempo_impor), yend = 0), linewidth = 1) +
labs(title = "Función de cuantía", x = "Días", y = "h_j") +
theme_minimal()
# Función de cuantía acumulada (CDF discreta)
tabla_frec_horiz <- tabla_frec %>%
mutate(tiempo_previo = dplyr::lag(tiempo_impor, default = min(tiempo_impor) - 1),
H_previo = dplyr::lag(H_j, default = 0))
print(tabla_frec_horiz)
ggplot() +
geom_segment(data = tabla_frec_horiz,
aes(x = tiempo_previo, xend = tiempo_impor,
y = H_previo, yend = H_previo),
arrow = arrow(type = "open", length = unit(0.2, "cm")),
linewidth = 1) +
geom_point(data = tabla_frec_horiz,
aes(x = tiempo_previo, y = H_previo),
size = 2) +
geom_segment(data = tabla_frec_horiz,
aes(x = tiempo_impor, xend = tiempo_impor,
y = H_previo, yend = H_j),
linetype = "dashed", linewidth = 1) +
scale_x_continuous(breaks = 0:15, minor_breaks = NULL) +
labs(title = "Función de cuantía acumulada",
x = "Días", y = "H_j") +
geom_segment(aes(x = max(tabla_frec$tiempo_impor),
xend = max(tabla_frec$tiempo_impor) + 1,
y = 1, yend = 1),
arrow = arrow(type = "open", length = unit(0.2, "cm")),
linewidth = 1) +
theme_minimal()
# Estadísticos descriptivos
tabla_vertical <- datos_wdi %>%
filter(!is.na(tiempo_impor)) %>%
summarise(
`n` = n(),
`mínimo` = min(tiempo_impor),
`máximo` = max(tiempo_impor),
`moda` = tiempo_impor %>% table() %>% which.max() %>% names() %>% as.numeric(),
`media` = mean(tiempo_impor),
`mediana` = median(tiempo_impor),
`cuartil 1 (x_{0.25})` = quantile(tiempo_impor, 0.25),
`cuartil 3 (x_{0.75})` = quantile(tiempo_impor, 0.75),
`rango` = max(tiempo_impor) - min(tiempo_impor),
`IQR` = IQR(tiempo_impor),
`varianza` = var(tiempo_impor),
`desvío estándar` = sd(tiempo_impor),
`coef. variación (CV)` = sd(tiempo_impor) / mean(tiempo_impor),
`asimetría (γ₁)` = moments::skewness(tiempo_impor),
`apuntamiento (γ₂)` = moments::kurtosis(tiempo_impor)
) %>%
pivot_longer(everything(), names_to = "Medida", values_to = "Valor")
kable(tabla_vertical, digits = 2)
# ----------------------
# EJEMPLO VARIABLE CONTINUA
# ----------------------
# Descargar datos (PIB per cápita)
datos_pib <- WDI(
indicator = "NY.GDP.PCAP.CD",
country = "all",
latest    = 1,
extra     = TRUE
)
